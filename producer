from kafka import KafkaProducer
import json
import ssl
import time
import traceback

# --- Configuration Kafka ---
BROKER = "mon-broker.kafka:9093"
TOPIC = "mon_topic"
FICHIER = "donnees.txt"

# --- Authentification SASL_SSL ---
SASL_MECHANISM = "PLAIN"  # ou SCRAM-SHA-512 selon ton cluster
SECURITY_PROTOCOL = "SASL_SSL"
SASL_USERNAME = "mon_utilisateur"
SASL_PASSWORD = "mon_mot_de_passe"

# --- Fichiers SSL ---
TRUSTSTORE_PATH = "/chemin/vers/truststore.pem"

# --- Délai entre envois ---
DELAY = 1

def create_ssl_context():
    """
    Crée un contexte SSL à partir du truststore.
    """
    context = ssl.create_default_context(cafile=TRUSTSTORE_PATH)
    context.check_hostname = True
    context.verify_mode = ssl.CERT_REQUIRED
    return context

def main():
    ssl_context = create_ssl_context()

    producer = KafkaProducer(
        bootstrap_servers=[BROKER],
        security_protocol=SECURITY_PROTOCOL,
        sasl_mechanism=SASL_MECHANISM,
        sasl_plain_username=SASL_USERNAME,
        sasl_plain_password=SASL_PASSWORD,
        ssl_context=ssl_context,
        value_serializer=lambda v: json.dumps(v).encode("utf-8"),
        key_serializer=lambda k: str(k).encode("utf-8") if k else None,
        compression_type="gzip",  # ✅ Compression activée
        retries=3,
        acks="all"
    )

    print(f"Connexion sécurisée SASL_SSL au broker {BROKER}")
    print(f"Compression activée : gzip")
    print(f"Envoi des messages du fichier '{FICHIER}' vers le topic '{TOPIC}'...\n")

    try:
        with open(FICHIER, "r", encoding="utf-8") as f:
            for i, ligne in enumerate(f):
                ligne = ligne.strip()
                if not ligne:
                    continue

                message = {"index": i, "ligne": ligne}
                try:
                    future = producer.send(TOPIC, key=i, value=message)
                    record_metadata = future.get(timeout=10)
                    print(f"[✓] Message {i} envoyé (partition={record_metadata.partition}, offset={record_metadata.offset})")

                except Exception as send_error:
                    print(f"❌ Erreur lors de l'envoi du message {i} : {send_error}")
                    traceback.print_exc()

                time.sleep(DELAY)

        try:
            producer.flush(timeout=10)
        except Exception as flush_error:
            print("❌ Erreur lors du flush des messages restants :")
            traceback.print_exc()

        print("\n✅ Fin du traitement.")

    except Exception as global_error:
        print("❌ Erreur inattendue dans le producer :")
        traceback.print_exc()

    finally:
        producer.close()

if __name__ == "__main__":
    main()
